<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robocop Review Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .review-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .review-content.expanded {
            max-height: 2000px;
            transition: max-height 0.5s ease-in;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .resolved-row {
            opacity: 0.5;
            background-color: #f8f9fa !important;
        }
        .resolved-row:hover {
            background-color: #f1f3f4 !important;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold text-gray-900">Robocop Code Review Dashboard</h1>
            <button 
                onclick="openSettingsModal()" 
                class="p-2 text-gray-400 hover:text-gray-600 rounded-md hover:bg-gray-100"
                title="Settings"
            >
                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path>
                </svg>
            </button>
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
            <div class="flex items-center justify-center min-h-screen p-4">
                <div class="bg-white rounded-lg shadow-xl max-w-md w-full">
                    <div class="flex items-center justify-between p-6 border-b">
                        <h3 class="text-lg font-semibold text-gray-900">Settings</h3>
                        <button 
                            onclick="closeSettingsModal()" 
                            class="p-1 text-gray-400 hover:text-gray-600 rounded-md hover:bg-gray-100"
                        >
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="p-6">
                        <div class="mb-4">
                            <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-2">OpenAI API Key</label>
                            <input 
                                type="password" 
                                id="apiKey" 
                                placeholder="sk-..." 
                                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                        </div>
                        <div class="flex justify-end gap-3">
                            <button 
                                onclick="closeSettingsModal()" 
                                class="px-4 py-2 text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-500"
                            >
                                Cancel
                            </button>
                            <button 
                                onclick="saveApiKey()" 
                                class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            >
                                Save
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="bg-white rounded-lg shadow p-6 mb-6">
            <div class="flex items-center gap-6">
                <div class="flex items-center gap-2">
                    <label for="refreshInterval" class="font-semibold text-gray-700">Auto-refresh:</label>
                    <select 
                        id="refreshInterval" 
                        onchange="updateRefreshInterval()"
                        class="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                        <option value="0">Off</option>
                        <option value="30">30s</option>
                        <option value="60" selected>1m</option>
                        <option value="120">2m</option>
                        <option value="300">5m</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <button 
                        onclick="loadBatches()" 
                        id="refreshBtn"
                        class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500"
                    >
                        Refresh Now
                    </button>
                    <div id="loading" class="hidden">
                        <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
                    </div>
                </div>
                <div id="lastUpdate" class="text-sm text-gray-500 ml-auto"></div>
            </div>
        </div>

        <!-- Error Display -->
        <div id="error" class="hidden bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
            <p class="text-red-800"></p>
        </div>

        <!-- Batches Table -->
        <div id="batchesContainer" class="bg-white rounded-lg shadow overflow-hidden overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Resolved</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Created</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Branch</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Repo/PR</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Source Commit</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Target Commit</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Review</th>
                    </tr>
                </thead>
                <tbody id="batchesBody" class="bg-white divide-y divide-gray-200">
                    <!-- Batches will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let refreshTimer = null;
        let isLoadingBatches = false;
        const API_BASE = 'https://api.openai.com/v1';
        
        // State preservation
        let uiState = {
            expandedRows: new Set(),
            expandedReasoning: new Set(),
            textSelection: null
        };

        function saveCurrentUIState() {
            // Save text selection
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                
                // Find the closest element with an ID that we can use to restore selection
                let element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
                while (element && !element.id) {
                    element = element.parentElement;
                }
                
                if (element && element.id) {
                    const startPath = getNodePath(range.startContainer, element);
                    const endPath = getNodePath(range.endContainer, element);
                    
                    // Only save selection if both paths are valid
                    if (startPath !== null && endPath !== null) {
                        uiState.textSelection = {
                            elementId: element.id,
                            startOffset: range.startOffset,
                            endOffset: range.endOffset,
                            startContainerPath: startPath,
                            endContainerPath: endPath
                        };
                    } else {
                        uiState.textSelection = null;
                    }
                } else {
                    uiState.textSelection = null;
                }
            } else {
                uiState.textSelection = null;
            }
        }

        function getNodePath(node, root) {
            const path = [];
            let current = node;
            
            // Verify that root is actually an ancestor of node
            if (!root.contains(node) && root !== node) {
                return null; // Return null if root is not an ancestor
            }
            
            while (current && current !== root) {
                const parent = current.parentNode;
                if (parent) {
                    const index = Array.from(parent.childNodes).indexOf(current);
                    path.unshift(index);
                }
                current = parent;
            }
            return path;
        }

        function getNodeByPath(root, path) {
            let current = root;
            for (const index of path) {
                if (current.childNodes[index]) {
                    current = current.childNodes[index];
                } else {
                    return null;
                }
            }
            return current;
        }

        function restoreUIState() {
            // Restore expanded rows
            uiState.expandedRows.forEach(batchId => {
                // batchId stored in state needs to be normalized for DOM lookup
                const normalizedBatchId = normalizeId(batchId);
                const content = document.getElementById(`review-${normalizedBatchId}`);
                const button = document.getElementById(`btn-${normalizedBatchId}`);
                if (content && button) {
                    content.classList.add('expanded');
                    button.textContent = '▼ Hide';
                }
            });

            // Restore expanded reasoning
            uiState.expandedReasoning.forEach(batchId => {
                // batchId stored in state needs to be normalized for DOM lookup
                const normalizedBatchId = normalizeId(batchId);
                const reasoning = document.getElementById(`reasoning-${normalizedBatchId}`);
                const button = document.getElementById(`reasoning-btn-${normalizedBatchId}`);
                if (reasoning && button) {
                    reasoning.classList.remove('hidden');
                    button.textContent = 'Hide Reasoning';
                }
            });

            // Restore text selection
            if (uiState.textSelection) {
                setTimeout(() => {
                    const element = document.getElementById(uiState.textSelection.elementId);
                    if (element) {
                        const startNode = getNodeByPath(element, uiState.textSelection.startContainerPath);
                        const endNode = getNodeByPath(element, uiState.textSelection.endContainerPath);
                        
                        if (startNode && endNode) {
                            const selection = window.getSelection();
                            const range = document.createRange();
                            try {
                                range.setStart(startNode, uiState.textSelection.startOffset);
                                range.setEnd(endNode, uiState.textSelection.endOffset);
                                selection.removeAllRanges();
                                selection.addRange(range);
                            } catch (e) {
                                // Selection restoration failed, clear saved state
                                uiState.textSelection = null;
                            }
                        }
                    }
                }, 100); // Small delay to ensure DOM is fully rendered
            }
        }

        // Load API key on page load
        window.onload = function() {
            const savedKey = localStorage.getItem('openai_api_key');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
                loadBatches();
            } else {
                openSettingsModal();
            }
            updateRefreshInterval();
            
            // Pause refresh when tab is hidden
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    console.log('Tab hidden, pausing auto-refresh');
                    // Clear the interval when tab is hidden
                    if (refreshTimer) {
                        clearInterval(refreshTimer);
                        refreshTimer = null;
                    }
                } else {
                    console.log('Tab visible, restarting auto-refresh');
                    // Restart the interval when tab becomes visible
                    updateRefreshInterval();
                    // Also immediately refresh to get any new data
                    if (!isLoadingBatches) {
                        loadBatches();
                    }
                }
            });
            
            // Set up event delegation for dynamically added buttons
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('review-toggle-btn')) {
                    const batchId = e.target.getAttribute('data-batch-id');
                    if (batchId) {
                        toggleReview(batchId);
                    }
                } else if (e.target.classList.contains('reasoning-toggle-btn')) {
                    const batchId = e.target.getAttribute('data-batch-id');
                    if (batchId) {
                        toggleReasoning(batchId);
                    }
                }
            });
            
            document.addEventListener('change', function(e) {
                if (e.target.classList.contains('resolved-checkbox')) {
                    const batchId = e.target.getAttribute('data-batch-id');
                    if (batchId) {
                        toggleResolved(batchId);
                    }
                }
            });
        };

        function openSettingsModal() {
            document.getElementById('settingsModal').classList.remove('hidden');
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.add('hidden');
        }

        function saveApiKey() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (apiKey) {
                localStorage.setItem('openai_api_key', apiKey);
                showMessage('API key saved', 'success');
                closeSettingsModal();
                loadBatches();
            }
        }

        function getApiKey() {
            return document.getElementById('apiKey').value.trim() || localStorage.getItem('openai_api_key');
        }

        function getResolvedState(batchId) {
            const resolved = localStorage.getItem('robocop_resolved') || '{}';
            try {
                return JSON.parse(resolved)[batchId] || false;
            } catch (e) {
                return false;
            }
        }

        function setResolvedState(batchId, resolved) {
            const current = localStorage.getItem('robocop_resolved') || '{}';
            try {
                const resolvedData = JSON.parse(current);
                resolvedData[batchId] = resolved;
                localStorage.setItem('robocop_resolved', JSON.stringify(resolvedData));
            } catch (e) {
                const resolvedData = {};
                resolvedData[batchId] = resolved;
                localStorage.setItem('robocop_resolved', JSON.stringify(resolvedData));
            }
        }

        function showMessage(message, type = 'error') {
            const errorDiv = document.getElementById('error');
            const textElement = errorDiv.querySelector('p');
            textElement.textContent = message;

            if (type === 'success') {
                errorDiv.className = 'bg-green-50 border border-green-200 rounded-lg p-4 mb-6';
                textElement.className = 'text-green-800';
            } else {
                errorDiv.className = 'bg-red-50 border border-red-200 rounded-lg p-4 mb-6';
                textElement.className = 'text-red-800';
            }

            errorDiv.classList.remove('hidden');
            setTimeout(() => errorDiv.classList.add('hidden'), 5000);
        }

        function updateRefreshInterval() {
            const interval = parseInt(document.getElementById('refreshInterval').value);
            console.log(`Updating refresh interval to ${interval} seconds`);
            if (refreshTimer) {
                clearInterval(refreshTimer);
                refreshTimer = null;
                console.log('Cleared existing refresh timer');
            }
            if (interval > 0 && !document.hidden) {
                refreshTimer = setInterval(loadBatches, interval * 1000);
                console.log(`Set new refresh timer: ${interval * 1000}ms`);
            } else if (interval > 0 && document.hidden) {
                console.log('Not setting timer - tab is hidden');
            } else {
                console.log('Auto-refresh disabled');
            }
        }

        function getRelativeTime(timestamp) {
            const seconds = Math.floor((Date.now() / 1000) - timestamp);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function getStatusBadge(status) {
            const colors = {
                'completed': 'bg-green-100 text-green-800',
                'failed': 'bg-red-100 text-red-800',
                'expired': 'bg-red-100 text-red-800',
                'in_progress': 'bg-yellow-100 text-yellow-800',
                'validating': 'bg-yellow-100 text-yellow-800',
                'finalizing': 'bg-yellow-100 text-yellow-800',
                'cancelling': 'bg-gray-100 text-gray-800',
                'cancelled': 'bg-gray-100 text-gray-800'
            };
            const color = colors[status] || 'bg-gray-100 text-gray-800';
            const escapedStatus = escapeHtml(status);
            return `<span class="px-2 py-1 text-xs font-semibold rounded-full ${color}">${escapedStatus}</span>`;
        }

        function formatCommitHash(hash, full = false) {
            if (!hash) return 'N/A';
            const short = hash.substring(0, 7);
            // Always returns plain text (never HTML) for consistent behavior
            return full ? hash : short;
        }

        function toggleReview(batchId) {
            const normalizedBatchId = normalizeId(batchId);
            const content = document.getElementById(`review-${normalizedBatchId}`);
            const button = document.getElementById(`btn-${normalizedBatchId}`);
            content.classList.toggle('expanded');
            button.textContent = content.classList.contains('expanded') ? '▼ Hide' : '▶ Show';
            
            // Update state tracking - use raw batchId for storage
            if (content.classList.contains('expanded')) {
                uiState.expandedRows.add(batchId);
            } else {
                uiState.expandedRows.delete(batchId);
            }
        }

        function toggleReasoning(batchId) {
            const normalizedBatchId = normalizeId(batchId);
            const reasoning = document.getElementById(`reasoning-${normalizedBatchId}`);
            const button = document.getElementById(`reasoning-btn-${normalizedBatchId}`);
            reasoning.classList.toggle('hidden');
            button.textContent = reasoning.classList.contains('hidden') ? 'Show Reasoning' : 'Hide Reasoning';
            
            // Update state tracking - use raw batchId for storage
            if (!reasoning.classList.contains('hidden')) {
                uiState.expandedReasoning.add(batchId);
            } else {
                uiState.expandedReasoning.delete(batchId);
            }
        }

        function toggleResolved(batchId) {
            const currentState = getResolvedState(batchId);
            setResolvedState(batchId, !currentState);
            
            // Update the checkbox
            const normalizedBatchId = normalizeId(batchId);
            const checkbox = document.getElementById(`resolved-${normalizedBatchId}`);
            if (checkbox) {
                checkbox.checked = !currentState;
            }
            
            // Update the row styling
            const row = checkbox?.closest('tr');
            if (row) {
                if (!currentState) {
                    // Now resolved
                    row.className = 'resolved-row';
                } else {
                    // No longer resolved
                    row.className = 'hover:bg-gray-50';
                }
            }
        }

        async function fetchBatchOutput(fileId) {
            const apiKey = getApiKey();
            const response = await fetch(`${API_BASE}/files/${fileId}/content`, {
                headers: {
                    'Authorization': `Bearer ${apiKey}`
                }
            });
            if (!response.ok) throw new Error(`Failed to fetch output file: ${response.statusText}`);
            return await response.text();
        }

        function parseReviewFromOutput(outputText) {
            const lines = outputText.trim().split('\n');
            for (const line of lines) {
                if (!line.trim()) continue;
                
                try {
                    const result = JSON.parse(line.trim());
                    if (result.custom_id === 'robocop-review-1' && result.response?.body?.choices?.[0]?.message?.content) {
                        const content = result.response.body.choices[0].message.content;
                        return parseJsonContent(content);
                    }
                } catch (jsonError) {
                    // Skip malformed JSON lines and continue processing other lines
                    console.warn('Skipping malformed JSON line:', line.substring(0, 100));
                    continue;
                }
            }
            
            // Log if no valid review was found in any line
            console.warn('No valid robocop review found in output');
            return null;
        }
        
        function parseJsonContent(content) {
            try {
                return JSON.parse(content);
            } catch (e) {
                console.warn('Failed to parse model content as JSON:', content.substring(0, 100), 'Error:', e.message);
                return null;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function normalizeId(id) {
            // Create a collision-resistant safe HTML ID using base64url encoding
            // This avoids collisions that can occur with simple character replacement
            try {
                // Convert to base64 and make it URL-safe
                const base64 = btoa(id)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
                // Prefix with 'id_' to ensure it starts with a letter
                return 'id_' + base64;
            } catch (e) {
                // Fallback to simple replacement if btoa fails
                return 'id_' + id.replace(/[^a-zA-Z0-9\-_]/g, '_');
            }
        }

        function createSafeRepoLink(repoName, url, pullRequestUrl) {
            // Sanitize pull request URL if provided, otherwise sanitize repo URL
            const safePrUrl = pullRequestUrl ? getSafeRepoUrl(pullRequestUrl) : null;
            const safeUrl = url ? getSafeRepoUrl(url) : null;
            const linkUrl = safePrUrl || safeUrl;
            
            if (!linkUrl) {
                return escapeHtml(repoName || 'N/A');
            }
            
            // Create anchor element safely using DOM methods
            const link = document.createElement('a');
            link.href = linkUrl; // href assignment does not sanitize protocols
            link.textContent = repoName || 'N/A'; // textContent avoids HTML injection
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.className = 'text-blue-600 hover:text-blue-800 hover:underline';
            
            return link.outerHTML;
        }

        function getSafeRepoUrl(remoteUrl) {
            if (!remoteUrl) return null;
            
            // Only allow http/https URLs
            if (/^https?:\/\//i.test(remoteUrl)) {
                return remoteUrl;
            }
            
            // Normalize common SSH-style URLs to HTTPS
            // Handle git@github.com:org/repo.git -> https://github.com/org/repo
            const sshMatch = remoteUrl.match(/^git@([^:]+):(.+?)(?:\.git)?$/);
            if (sshMatch) {
                const [, host, path] = sshMatch;
                if (host === 'github.com' || host === 'gitlab.com' || host === 'bitbucket.org') {
                    return `https://${host}/${path}`;
                }
            }
            
            // Handle ssh://git@host/path -> https://host/path
            const sshProtocolMatch = remoteUrl.match(/^ssh:\/\/(?:git@)?([^\/]+)\/(.+?)(?:\.git)?$/);
            if (sshProtocolMatch) {
                const [, host, path] = sshProtocolMatch;
                if (host === 'github.com' || host === 'gitlab.com' || host === 'bitbucket.org') {
                    return `https://${host}/${path}`;
                }
            }
            
            // If we can't safely convert it, return null (no link)
            return null;
        }

        function renderReview(batch) {
            const review = batch.reviewData;
            if (!review) {
                return '<span class="text-gray-400 text-sm">Review not available</span>';
            }

            const hasComments = review.substantiveComments;
            const summaryClass = hasComments ? 'text-orange-600 font-semibold' : 'text-green-600';
            const summaryText = hasComments ? 'Issues Found' : 'No Issues';

            // Escape model output to prevent XSS
            const escapedSummary = escapeHtml(review.summary || 'n/a');
            const escapedReasoning = escapeHtml(review.reasoning || 'N/A');

            // Normalize the batch ID for safe use in HTML IDs
            const normalizedBatchId = normalizeId(batch.id);
            // Use raw batch ID for data attributes to avoid mismatch issues
            const rawBatchId = batch.id;
            
            return `
                <button
                    id="btn-${normalizedBatchId}"
                    data-batch-id="${rawBatchId}"
                    class="text-blue-600 hover:text-blue-800 font-medium text-sm review-toggle-btn"
                >
                    ▶ Show
                </button>
                <span class="${summaryClass} ml-2 text-sm">${summaryText}</span>
                <div id="review-${normalizedBatchId}" class="review-content mt-2">
                    <div class="bg-gray-50 rounded p-3 mt-2 text-sm">
                        <div class="mb-2">
                            <strong class="text-gray-700">Substantive Comments:</strong>
                            <span class="${hasComments ? 'text-orange-600' : 'text-green-600'} font-semibold">
                                ${hasComments ? 'Yes' : 'No'}
                            </span>
                        </div>
                        <div class="mb-2">
                            <strong class="text-gray-700">Summary:</strong>
                            <pre class="mt-1 text-gray-800">${escapedSummary}</pre>
                        </div>
                        <div class="mt-3">
                            <button
                                id="reasoning-btn-${normalizedBatchId}"
                                data-batch-id="${rawBatchId}"
                                class="text-sm text-blue-600 hover:text-blue-800 font-medium reasoning-toggle-btn"
                            >
                                Show Reasoning
                            </button>
                            <div id="reasoning-${normalizedBatchId}" class="hidden mt-2">
                                <strong class="text-gray-700">Reasoning:</strong>
                                <pre class="mt-1 text-gray-600 bg-white p-2 rounded border border-gray-200">${escapedReasoning}</pre>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function loadBatches() {
            if (isLoadingBatches) {
                console.log('Skipping loadBatches - already in progress');
                return; // Prevent overlapping loads
            }
            
            const apiKey = getApiKey();
            if (!apiKey) {
                showMessage('Please enter an API key');
                return;
            }

            console.log('Starting loadBatches');
            isLoadingBatches = true;

            // Save current UI state before reloading
            saveCurrentUIState();

            const loading = document.getElementById('loading');
            const refreshBtn = document.getElementById('refreshBtn');
            loading.classList.remove('hidden');
            refreshBtn.disabled = true;

            try {
                // Fetch batches
                const response = await fetch(`${API_BASE}/batches?limit=100`, {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.statusText}`);
                }

                const data = await response.json();
                
                // Filter for robocop batches with schema version 1
                const roboCopBatches = data.data.filter(batch =>
                    batch.metadata?.description === 'robocop code review tool' &&
                    batch.metadata?.metadata_schema === '1'
                );

                console.log(`Found ${roboCopBatches.length} robocop batches`);

                // Cache for completed batch review data
                const cachedReviews = JSON.parse(localStorage.getItem('robocop_review_cache') || '{}');

                // Detect errors in batches
                roboCopBatches.forEach(batch => {
                    // Check for errors using request_counts.failed or presence of error_file_id
                    const failedCount = batch.request_counts?.failed || 0;
                    batch.hasErrors = failedCount > 0 || !!batch.error_file_id;
                    batch.failedCount = failedCount;
                    batch.errorFileId = batch.error_file_id;
                });

                // Fetch output for completed batches in parallel (only if not already cached)
                const outputPromises = roboCopBatches
                    .filter(batch => batch.status === 'completed' && batch.output_file_id)
                    .map(async batch => {
                        // Check if we already have cached review data for this batch
                        if (cachedReviews[batch.id]) {
                            batch.reviewData = cachedReviews[batch.id];
                            return;
                        }

                        try {
                            const output = await fetchBatchOutput(batch.output_file_id);
                            batch.reviewData = parseReviewFromOutput(output);

                            // Cache the review data for completed batches
                            if (batch.reviewData) {
                                cachedReviews[batch.id] = batch.reviewData;
                                localStorage.setItem('robocop_review_cache', JSON.stringify(cachedReviews));
                            }
                        } catch (e) {
                            console.error(`Failed to fetch output for batch ${batch.id}:`, e);
                        }
                    });

                await Promise.all(outputPromises);

                renderBatches(roboCopBatches);
                
                // Restore UI state after rendering
                restoreUIState();
                
                document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                console.log('loadBatches completed successfully');
                
            } catch (error) {
                console.error('Error loading batches:', error);
                showMessage(`Error: ${error.message}`);
            } finally {
                loading.classList.add('hidden');
                refreshBtn.disabled = false;
                isLoadingBatches = false;
                console.log('loadBatches finished, isLoadingBatches reset to false');
            }
        }

        function renderBatches(batches) {
            const tbody = document.getElementById('batchesBody');
            
            if (batches.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="8" class="px-6 py-4 text-center text-gray-500">
                            No robocop review batches found
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = batches.map(batch => {
                const normalizedBatchId = normalizeId(batch.id);
                const rawBatchId = batch.id;
                const isResolved = getResolvedState(batch.id);
                const rowClass = isResolved ? "resolved-row" : "hover:bg-gray-50";
                return `
                <tr class="${rowClass}">
                    <td class="px-6 py-4 text-center">
                        ${batch.status === 'completed' && batch.reviewData?.substantiveComments ? 
                            `<input 
                                type="checkbox" 
                                id="resolved-${normalizedBatchId}" 
                                data-batch-id="${rawBatchId}"
                                class="w-4 h-4 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500 focus:ring-2 resolved-checkbox"
                            />` : 
                            '<span class="text-gray-400">-</span>'
                        }
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap">
                        ${getStatusBadge(batch.status)}
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        <span title="${new Date(batch.created_at * 1000).toLocaleString()}">
                            ${getRelativeTime(batch.created_at)}
                        </span>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        ${escapeHtml(batch.metadata?.branch || 'N/A')}
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 font-medium">
                        ${createSafeRepoLink(batch.metadata?.repo_name, getSafeRepoUrl(batch.metadata?.remote_url), batch.metadata?.pull_request_url)}
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-mono text-gray-900">
                        <span title="${escapeHtml(batch.metadata?.source_commit || 'N/A')}">
                            ${formatCommitHash(batch.metadata?.source_commit)}
                        </span>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-mono text-gray-900">
                        <span title="${escapeHtml(batch.metadata?.target_commit || 'N/A')}">
                            ${formatCommitHash(batch.metadata?.target_commit)}
                        </span>
                    </td>
                    <td class="px-6 py-4 text-sm">
                        ${batch.status === 'completed' ? renderReview(batch) :
                          `<span class="text-gray-400">Pending (${escapeHtml(batch.status)})</span>`}
                    </td>
                </tr>
            `;}).join('');

            // Set checkbox states after DOM is updated
            batches.forEach(batch => {
                if (batch.status === 'completed' && batch.reviewData?.substantiveComments) {
                    const normalizedBatchId = normalizeId(batch.id);
                    const checkbox = document.getElementById(`resolved-${normalizedBatchId}`);
                    if (checkbox) {
                        checkbox.checked = getResolvedState(batch.id);
                    }
                }
            });
        }
    </script>
</body>
</html>
